diff --git a/Makefile b/Makefile
index b971308..772555e 100644
--- a/Makefile
+++ b/Makefile
@@ -157,7 +157,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
-
+    $U/_sleep\
+	$U/_pingpong\
+	$U/_find\
 
 ifeq ($(LAB),syscall)
 UPROGS += \
@@ -242,15 +244,8 @@ qemu-gdb: $K/kernel .gdbinit fs.img
 	@echo "*** Now run 'gdb' in another window." 1>&2
 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
 
-GDBARGS = 
-GDBARGS += -ex 'set architecture riscv:rv64'
-GDBARGS += -ex 'target remote 127.0.0.1:$(GDBPORT)'
-GDBARGS += -ex 'symbol-file kernel/kernel'
-GDBARGS += -ex 'set riscv use-compressed-breakpoints yes'
-
-
 gdb: 
-	$(GDB) $(GDBARGS)
+	$(GDB)
 
 ##
 ##  FOR testing lab grading script
diff --git a/commands.gdb b/commands.gdb
new file mode 100644
index 0000000..3d5d6a6
--- /dev/null
+++ b/commands.gdb
@@ -0,0 +1,136 @@
+si
+si
+si
+si
+si
+si
+b *0x80000086
+c
+u 58
+info registers mepc
+si
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+s
+n
+n
+n
+n
+n
+n
+n
+p p->name
+fin
+b main.c:42
+c
+s
+n
+n
+n
+n
+n
+n
+p p->name
+n
+n
+si
+si
+si
+si
+si
+si
+si
+si 10
+si 10
+si
+si
+si
+si
+si
+i r ra
+si
+n
+n
+n
+n
+n
+s
+n
+p p->name
+u 112
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si 10
+si 10
+si 10
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+i r stvec
+i r scause
+si
+i r scause
+i r stvec
+si 10
+si 10
+si 10
+si 5
+si
+si
+si
+si
+n
+n
+n
+n
+n
+p p->name
+n
+n
+n
+n
+i r scause
+n
+n
+n
+n
+n
+s
+n
+p p->name
+da
+q
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..d0923df
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,86 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+char* fmtname(char* path) {
+  static char buf[DIRSIZ + 1];
+  char* p;
+
+  // Find first character after last slash
+  for (p = path + strlen(path); p >= path && *p != '/'; p--)
+    ;
+  p++;
+
+  // Return name without leading spaces
+  if (strlen(p) >= DIRSIZ)
+    return p;
+  memmove(buf, p, strlen(p));
+  buf[strlen(p)] = '\0';
+  return buf;
+}
+
+void find(char* path, char* filename) {
+  char buf[512], name[DIRSIZ + 1], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+
+  if ((fd = open(path, 0)) < 0) {
+    fprintf(2, "find: cannot open %s\n", path);
+    return;
+  }
+
+  if (fstat(fd, &st) < 0) {
+    fprintf(2, "find: cannot stat %s\n", path);
+    close(fd);
+    return;
+  }
+
+  char* path_name = fmtname(path);
+  if (strcmp(path_name, filename) == 0) {
+    printf("%s\n", path);
+  }
+
+  if (st.type == T_DIR) {
+    if (strlen(path) + 1 + DIRSIZ + 1 > sizeof(buf)) {
+      printf("find: path too long\n");
+      close(fd);
+      return;
+    }
+
+    while (read(fd, &de, sizeof(de)) == sizeof(de)) {
+      if (de.inum == 0)
+        continue;
+
+      memmove(name, de.name, DIRSIZ);
+      name[DIRSIZ] = '\0';
+
+      if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0)
+        continue;
+
+      // Construct the new path
+      strcpy(buf, path);
+      p = buf + strlen(buf);
+      *p++ = '/';
+      strcpy(p, name);
+
+      if (stat(buf, &st) < 0) {
+        printf("find: cannot stat %s\n", buf);
+        continue;
+      }
+
+      find(buf, filename);
+    }
+  }
+  close(fd);
+}
+
+int main(int argc, char* argv[]) {
+  if (argc < 3) {
+    fprintf(2, "Usage: find <path> <name>\n");
+    exit(1);
+  }
+  find(argv[1], argv[2]);
+  exit(0);
+}
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..858841e
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,37 @@
+#include "kernel/types.h"
+#include "user.h"
+
+#define MAXSIZE 100
+
+int main(int argc, char* argv[]){
+    int p1_F2C[2], p2_C2F[2];
+    pipe(p1_F2C);
+    pipe(p2_C2F);
+
+    int father_pid = getpid();
+
+    int pid = fork();
+    if (pid == 0) { 
+        //子进程 
+        char child_buffer[10];
+        close(p1_F2C[1]); 
+        read(p1_F2C[0], child_buffer, MAXSIZE);
+        printf("%d: received %s from pid %d\n", getpid(), child_buffer, father_pid);        
+        close(p1_F2C[0]); 
+        close(p2_C2F[0]); 
+        write(p2_C2F[1], "pong", 10);       
+        close(p2_C2F[1]); 
+    } else { 
+        //父进程 
+        char father_buffer[10];
+        close(p1_F2C[0]); 
+        write(p1_F2C[1], "ping", 10);      
+        close(p1_F2C[1]); 
+        close(p2_C2F[1]); 
+        read(p2_C2F[0], father_buffer, MAXSIZE);
+        printf("%d: received %s from pid %d\n", getpid(), father_buffer, pid);        
+        close(p2_C2F[0]); 
+    }
+
+    exit(0);
+}
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..01aec51
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,13 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main(int argc, char* argv[]){
+    if(argc != 2){
+        printf("Sleep needs one argument!\n");
+        exit(-1);
+    }
+    int ticks = atoi(argv[1]);
+    sleep(ticks);
+    printf("(nothing happens for a little while)\n");
+    exit(0);
+}
\ No newline at end of file
